import Relationships from '../relationships/state/create';
import Relationship from '../relationships/state/relationship';
import RecordData, { ChangedAttributesHash } from '../../ts-interfaces/record-data';
import { JsonApiResource, JsonApiResourceIdentity, JsonApiBelongsToRelationship, JsonApiHasManyRelationship } from "../../ts-interfaces/record-data-json-api";
import { RelationshipRecordData } from '../../ts-interfaces/relationship-record-data';
import { RecordDataStoreWrapper } from '../../ts-interfaces/record-data-store-wrapper';
export default class RecordDataDefault implements RelationshipRecordData {
    store: any;
    modelName: string;
    __relationships: Relationships | null;
    __implicitRelationships: {
        [key: string]: Relationship;
    } | null;
    clientId: string;
    id: string | null;
    storeWrapper: RecordDataStoreWrapper;
    isDestroyed: boolean;
    _isNew: boolean;
    _bfsId: number;
    __attributes: any;
    __inFlightAttributes: any;
    __data: any;
    _scheduledDestroy: any;
    constructor(modelName: string, id: string | null, clientId: string, storeWrapper: RecordDataStoreWrapper, store: any);
    getResourceIdentifier(): JsonApiResourceIdentity;
    pushData(data: JsonApiResource, calculateChange: boolean): any;
    willCommit(): void;
    hasChangedAttributes(): boolean;
    isEmpty(): boolean;
    reset(): void;
    _setupRelationships(data: any): void;
    _updateChangedAttributes(): void;
    changedAttributes(): ChangedAttributesHash;
    isNew(): boolean;
    rollbackAttributes(): any;
    didCommit(data: JsonApiResource | null): string[];
    getHasMany(key: any): JsonApiHasManyRelationship;
    setDirtyHasMany(key: any, recordDatas: any): void;
    addToHasMany(key: any, recordDatas: any, idx: any): void;
    removeFromHasMany(key: any, recordDatas: any): void;
    commitWasRejected(): void;
    getBelongsTo(key: string): JsonApiBelongsToRelationship;
    setDirtyBelongsTo(key: string, recordData: RelationshipRecordData): void;
    setDirtyAttribute(key: string, value: any): void;
    getAttr(key: string): string;
    hasAttr(key: string): boolean;
    unloadRecord(): void;
    _cleanupOrphanedRecordDatas(): void;
    destroy(): void;
    isRecordInUse(): boolean;
    /**
      Computes the set of internal models reachable from `this` across exactly one
      relationship.
  
      @return {Array} An array containing the internal models that `this` belongs
      to or has many.
  
    */
    _directlyRelatedRecordDatas(): RecordData[];
    /**
      Computes the set of internal models reachable from this internal model.
  
      Reachability is determined over the relationship graph (ie a graph where
      nodes are internal models and edges are belongs to or has many
      relationships).
  
      @return {Array} An array including `this` and all internal models reachable
      from `this`.
    */
    _allRelatedRecordDatas(): RecordDataDefault[];
    isAttrDirty(key: string): boolean;
    _attributes: any;
    readonly _relationships: Relationships;
    _data: any;
    readonly _implicitRelationships: any;
    _inFlightAttributes: any;
    /**
     * Receives options passed to `store.createRecord` and is given the opportunity
     * to handle them.
     *
     * The return value is an object of options to pass to `Record.create()`
     *
     * @param options
     * @private
     */
    _initRecordCreateOptions(options: any): {};
    removeFromInverseRelationships(isNew?: boolean): void;
    _destroyRelationships(): void;
    clientDidCreate(): void;
    _changedKeys(updates: any): string[];
    toString(): string;
}
