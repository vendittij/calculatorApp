import RSVP from 'rsvp';
import RecordData from '../../ts-interfaces/record-data';
export default class InternalModel {
    id: string | null;
    store: any;
    modelName: string;
    clientId: string | null;
    __recordData: RecordData | null;
    _isDestroyed: boolean;
    isError: boolean;
    _pendingRecordArrayManagerFlush: boolean;
    _isDematerializing: boolean;
    isReloading: boolean;
    _doNotDestroy: boolean;
    isDestroying: boolean;
    _promiseProxy: any;
    _record: any;
    _scheduledDestroy: any;
    _modelClass: any;
    __deferredTriggers: any;
    __recordArrays: any;
    _references: any;
    _recordReference: any;
    _manyArrayCache: any;
    _retainedManyArrayCache: any;
    _relationshipPromisesCache: any;
    currentState: any;
    error: any;
    constructor(modelName: string, id: string | null, store: any, data: any, clientId: any);
    readonly modelClass: any;
    readonly type: any;
    readonly recordReference: any;
    _recordData: RecordData;
    readonly _recordArrays: any;
    readonly references: any;
    readonly _deferredTriggers: any;
    isHiddenFromRecordArrays(): any;
    isRecordInUse(): boolean;
    isEmpty(): any;
    isLoading(): any;
    isLoaded(): any;
    hasDirtyAttributes(): any;
    isSaving(): any;
    isDeleted(): any;
    isNew(): any;
    isValid(): any;
    dirtyType(): any;
    getRecord(properties?: any): any;
    resetRecord(): void;
    dematerializeRecord(): void;
    deleteRecord(): void;
    save(options: any): RSVP.Promise<{}>;
    startedReloading(): void;
    linkWasLoadedForRelationship(key: any, data: any): void;
    finishedReloading(): void;
    reload(options: any): RSVP.Promise<this>;
    unloadRecord(): void;
    hasScheduledDestroy(): boolean;
    cancelDestroy(): void;
    destroySync(): void;
    _checkForOrphanedInternalModels(): void;
    eachRelationship(callback: any, binding: any): any;
    getBelongsTo(key: any, options: any): any;
    getManyArray(key: any): any;
    fetchAsyncHasMany(relationshipMeta: any, jsonApi: any, manyArray: any, options: any): any;
    getHasMany(key: any, options: any): any;
    _updateLoadingPromiseForHasMany(key: any, promise: any, content?: any): any;
    reloadHasMany(key: any, options: any): any;
    reloadBelongsTo(key: any, options: any): any;
    destroyFromRecordData(): void;
    destroy(): void;
    eachAttribute(callback: any, binding: any): any;
    inverseFor(key: any): any;
    setupData(data: any): void;
    getAttributeValue(key: any): any;
    setDirtyHasMany(key: any, records: any): any;
    setDirtyBelongsTo(key: any, value: any): any;
    setDirtyAttribute(key: any, value: any): any;
    readonly isDestroyed: boolean;
    readonly hasRecord: boolean;
    createSnapshot(options: any): any;
    loadingData(promise: any): void;
    loadedData(): void;
    notFound(): void;
    pushedData(): void;
    hasChangedAttributes(): boolean;
    changedAttributes(): import("../../ts-interfaces/record-data").ChangedAttributesHash;
    adapterWillCommit(): void;
    adapterDidDirty(): void;
    send(name: any, context?: any): any;
    manyArrayRecordAdded(key: any): void;
    notifyHasManyChange(key: any, record: any, idx: any): void;
    notifyBelongsToChange(key: any, record: any): void;
    notifyPropertyChange(key: any): void;
    didCreateRecord(): void;
    rollbackAttributes(): void;
    transitionTo(name: any): void;
    _unhandledEvent(state: any, name: any, context: any): void;
    triggerLater(...args: any[]): void;
    _triggerDeferredTriggers(): void;
    removeFromInverseRelationships(isNew?: boolean): void;
    preloadData(preload: any): void;
    _preloadRelationship(key: any, preloadValue: any): {
        data: any;
    };
    _convertPreloadRelationshipToJSON(value: any, modelClass: any): {
        type: any;
        id: any;
    };
    updateRecordArrays(): void;
    setId(id: any): void;
    didError(error: any): void;
    didCleanError(): void;
    adapterDidCommit(data: any): void;
    addErrorMessageToAttribute(attribute: any, message: any): void;
    removeErrorMessageFromAttribute(attribute: any): void;
    clearErrorMessages(): void;
    hasErrors(): boolean;
    adapterDidInvalidate(errors: any): void;
    adapterDidError(error: any): void;
    toString(): string;
    referenceFor(kind: any, name: any): any;
}
