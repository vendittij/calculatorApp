import Relationship from './relationship';
import { RelationshipRecordData } from "../../../ts-interfaces/relationship-record-data";
import { JsonApiBelongsToRelationship, JsonApiResourceIdentity } from "../../../ts-interfaces/record-data-json-api";
import { RelationshipSchema } from "../../../ts-interfaces/record-data-schemas";
export default class BelongsToRelationship extends Relationship {
    inverseRecordData: RelationshipRecordData | null;
    canonicalState: RelationshipRecordData | null;
    key: string;
    constructor(store: any, inverseKey: string, relationshipMeta: RelationshipSchema, recordData: RelationshipRecordData, inverseIsAsync: boolean);
    setRecordData(recordData: RelationshipRecordData): void;
    setCanonicalRecordData(recordData: RelationshipRecordData): void;
    setInitialCanonicalRecordData(recordData: RelationshipRecordData): void;
    addCanonicalRecordData(recordData: RelationshipRecordData): void;
    inverseDidDematerialize(): void;
    removeCompletelyFromOwn(recordData: RelationshipRecordData): void;
    removeCompletelyFromInverse(): void;
    flushCanonical(): void;
    addRecordData(recordData: RelationshipRecordData): void;
    removeRecordDataFromOwn(recordData: RelationshipRecordData): void;
    removeAllRecordDatasFromOwn(): void;
    notifyBelongsToChange(): void;
    removeCanonicalRecordDataFromOwn(recordData: RelationshipRecordData): void;
    removeAllCanonicalRecordDatasFromOwn(): void;
    getData(): JsonApiBelongsToRelationship;
    /**
     * Flag indicating whether all inverse records are available
     *
     * true if the inverse exists and is loaded (not empty)
     * true if there is no inverse
     * false if the inverse exists and is not loaded (empty)
     *
     * @return {boolean}
     */
    readonly allInverseRecordsAreLoaded: boolean;
    updateData(data: JsonApiResourceIdentity, initial: boolean): void;
}
