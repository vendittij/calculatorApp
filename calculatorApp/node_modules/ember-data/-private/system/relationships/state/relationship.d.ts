import OrderedSet from '../../ordered-set';
import { RelationshipRecordData } from "../../..//ts-interfaces/relationship-record-data";
import { JsonApiRelationship } from "../../../ts-interfaces/record-data-json-api";
import { RelationshipSchema } from "../../../ts-interfaces/record-data-schemas";
interface ImplicitRelationshipMeta {
    key?: string;
    kind?: string;
    options: any;
}
export default class Relationship {
    inverseIsAsync: boolean | undefined;
    kind?: string;
    recordData: RelationshipRecordData;
    members: OrderedSet<RelationshipRecordData>;
    canonicalMembers: OrderedSet<RelationshipRecordData>;
    store: any;
    key: string | null;
    inverseKey: string | null;
    isAsync: boolean;
    isPolymorphic: boolean;
    relationshipMeta: ImplicitRelationshipMeta | RelationshipSchema;
    inverseKeyForImplicit: string;
    meta: any;
    __inverseMeta: any;
    _tempModelName: string;
    shouldForceReload: boolean;
    relationshipIsStale: boolean;
    hasDematerializedInverse: boolean;
    hasAnyRelationshipData: boolean;
    relationshipIsEmpty: boolean;
    link?: string | null;
    willSync?: boolean;
    constructor(store: any, inverseKey: string, relationshipMeta: ImplicitRelationshipMeta, recordData: RelationshipRecordData, inverseIsAsync?: boolean);
    readonly isNew: boolean;
    _inverseIsAsync(): boolean;
    _inverseIsSync(): boolean;
    _hasSupportForImplicitRelationships(recordData: RelationshipRecordData): boolean;
    _hasSupportForRelationships(recordData: RelationshipRecordData): boolean;
    readonly _inverseMeta: RelationshipSchema;
    recordDataDidDematerialize(): void;
    forAllMembers(callback: (im: RelationshipRecordData) => void): void;
    inverseDidDematerialize(inverseRecordData: RelationshipRecordData | null): void;
    updateMeta(meta: any): void;
    clear(): void;
    removeAllRecordDatasFromOwn(): void;
    removeAllCanonicalRecordDatasFromOwn(): void;
    removeRecordDatas(recordDatas: RelationshipRecordData[]): void;
    addRecordDatas(recordDatas: RelationshipRecordData[], idx?: number): void;
    addCanonicalRecordDatas(recordDatas: RelationshipRecordData[], idx: number): void;
    addCanonicalRecordData(recordData: RelationshipRecordData, idx?: number): void;
    setupInverseRelationship(recordData: RelationshipRecordData): void;
    removeCanonicalRecordDatas(recordDatas: RelationshipRecordData[], idx?: number): void;
    removeCanonicalRecordData(recordData: RelationshipRecordData, idx?: number): void;
    addRecordData(recordData: RelationshipRecordData, idx?: number): void;
    removeRecordData(recordData: RelationshipRecordData): void;
    removeRecordDataFromInverse(recordData: RelationshipRecordData): void;
    removeRecordDataFromOwn(recordData: RelationshipRecordData | null, idx?: number): void;
    removeCanonicalRecordDataFromInverse(recordData: RelationshipRecordData): void;
    removeCanonicalRecordDataFromOwn(recordData: RelationshipRecordData | null, idx?: number): void;
    removeCompletelyFromInverse(): void;
    removeCompletelyFromOwn(recordData: RelationshipRecordData): void;
    flushCanonical(): void;
    flushCanonicalLater(): void;
    updateLink(link: string | null): void;
    updateRecordDatasFromAdapter(recordDatas?: RelationshipRecordData[]): void;
    computeChanges(recordDatas?: RelationshipRecordData[]): void;
    notifyRecordRelationshipAdded(recordData?: any, idxs?: any): void;
    setHasAnyRelationshipData(value: boolean): void;
    setHasDematerializedInverse(value: boolean): void;
    setRelationshipIsStale(value: boolean): void;
    setRelationshipIsEmpty(value: boolean): void;
    push(payload: JsonApiRelationship, initial?: boolean): void;
    localStateIsEmpty(): void;
    updateData(payload?: any, initial?: any): void;
    destroy(): void;
}
export {};
