import Relationship from './relationship';
import { RelationshipRecordData } from "../../../ts-interfaces/relationship-record-data";
import { JsonApiHasManyRelationship } from "../../../ts-interfaces/record-data-json-api";
import { RelationshipSchema } from "../../../ts-interfaces/record-data-schemas";
export default class ManyRelationship extends Relationship {
    canonicalState: RelationshipRecordData[];
    currentState: RelationshipRecordData[];
    _willUpdateManyArray: boolean;
    _pendingManyArrayUpdates: any;
    key: string;
    constructor(store: any, inverseKey: string, relationshipMeta: RelationshipSchema, recordData: RelationshipRecordData, inverseIsAsync: boolean);
    addCanonicalRecordData(recordData: RelationshipRecordData, idx?: number): void;
    inverseDidDematerialize(inverseRecordData: RelationshipRecordData): void;
    addRecordData(recordData: RelationshipRecordData, idx?: number): void;
    removeCanonicalRecordDataFromOwn(recordData: RelationshipRecordData, idx: any): void;
    removeAllCanonicalRecordDatasFromOwn(): void;
    removeCompletelyFromOwn(recordData: RelationshipRecordData): void;
    flushCanonical(): void;
    removeRecordDataFromOwn(recordData: RelationshipRecordData, idx?: number): void;
    notifyRecordRelationshipAdded(): void;
    computeChanges(recordDatas?: RelationshipRecordData[]): void;
    setInitialRecordDatas(recordDatas: RelationshipRecordData[] | undefined): void;
    notifyManyArrayIsStale(): void;
    notifyHasManyChange(): void;
    getData(): JsonApiHasManyRelationship;
    updateData(data: any, initial: any): void;
    /**
     * Flag indicating whether all inverse records are available
     *
     * true if inverse records exist and are all loaded (all not empty)
     * true if there are no inverse records
     * false if the inverse records exist and any are not loaded (any empty)
     *
     * @return {boolean}
     */
    readonly allInverseRecordsAreLoaded: boolean;
}
